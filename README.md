I completed Task 4 by first designing the main table and the audit table in MySQL: I created a products table to hold the live data and a products_audit table to store audit entries (audit_id, product_id, action_type, old_value, new_value, changed_at). Next I wrote three AFTER triggers (after_product_insert, after_product_update, after_product_delete) using DELIMITER so I could include multi-line trigger bodies; each trigger inserts a human-readable old_value and/or new_value string into the audit table using CONCAT, and records the action type and timestamp. After writing the SQL script I ran sample operations—an INSERT, an UPDATE, and a DELETE—and then ran SELECT * FROM products_audit to verify that every change was logged correctly with the expected before/after values and timestamps. I saved the final SQL script, captured screenshots of the audit table showing the sample logs, and wrote a short README describing how to deploy the script and how the triggers work; the exercise taught me how to use triggers, DELIMITER, and simple change-logging patterns for auditing database modifications.
